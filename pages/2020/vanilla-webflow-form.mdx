---
title: "Second-guessing the modern web"
description: "Most websites today are built like commercial products by professionals and marketers, optimised to draw the largest audience, generate engagement and 'convert'. But there is also a smaller, less-visible web designed by regular people to simply to share their interests and hobbies with the world. A web that is unpolished, often quirky but often also fun, creative and interesting."
author: "Christopher Hugentobler"
publishedAt: "2020-03-29"
image: " "
---

# Second-guessing the modern web

#### Most websites today are built like commercial products by professionals and marketers, optimised to draw the largest audience, generate engagement and 'convert'. But there is also a smaller, less-visible web designed by regular people to simply to share their interests and hobbies with the world. A web that is unpolished, often quirky but often also fun, creative and interesting.

Yes, you can hook up a Webflow lead gen form to a back-end of your choice easily.

You can get:
1. Custom form validation - HTML5 validation is solid but ugly.
2. Contextual form errors before submission - so that users can easily identify what went wrong.

And you can do it without:
1. Dependency bloat - no more Vue or Jquery.
2. Styling bloat - by leveraging existing Webflow features and styling.

<Columns>

Let's save the user inputs in one object - _data_.

And the validity of each input in another - _valid_. Later _valid_ will also help us infer form validity and completeness.

```js
let data = {},
  valid = {}
```

</Columns>

<Columns>

When users interact with our form, we will want to update our objects _data_ and _valid_.

Setting key/values directly makes debugging and logging changes difficult. Instead, we'll setup _[Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)_ with set _traps_ to manage state.

In practice, that means replacing `data.name = 'Christopher'` with `dataChange.name = 'Christopher'`.

```js
const dataChange = new Proxy(data, {
  set: (target, key, value) => {
    key = key.toLowerCase(); value = value.toLowerCase()
    // console.log(`${key} set to ${value}`)
    target[key] = value
    return true
  }
})

const validChange = new Proxy(valid, {
  set: (target, key, value) => {
    // console.log(`${key} set to ${value}`)
    target[key] = value
    return true
  }
})
```
</Columns>

We'll need a reference to our Dom elements - one form and several inputs.

The submit button is an input of type _submit_, so filtering it from _inputs_ leaves us with _fields_.

## Managing form data and validity

We'll need a reference to our Dom elements - one form and several inputs.

The submit button is an input of type _submit_, so filtering it from _inputs_ leaves us with _fields_.
